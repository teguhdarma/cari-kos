"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _icons = require("@sanity/icons");

var _ui = require("@sanity/ui");

var _buttonCollection = _interopRequireDefault(require("part:@sanity/components/buttons/button-collection"));

var _content = _interopRequireDefault(require("part:@sanity/components/dialogs/content"));

var _default2 = _interopRequireDefault(require("part:@sanity/components/dialogs/default"));

var _default3 = _interopRequireDefault(require("part:@sanity/components/formfields/default"));

var _bar = _interopRequireDefault(require("part:@sanity/components/progress/bar"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _fi = require("react-icons/fi");

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _upload = require("../actions/upload");

var _SanityClient = _interopRequireDefault(require("../clients/SanityClient"));

var _extractFiles = require("../util/extractFiles");

var _FileInputButton = _interopRequireDefault(require("./FileInputButton"));

var _Uploader = _interopRequireDefault(require("./Uploader.css"));

var _UploadPlaceholder = _interopRequireDefault(require("./UploadPlaceholder"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ctrlKey = 17;
var cmdKey = 91;
var propTypes = {
  hasFocus: _propTypes.default.bool,
  onFocus: _propTypes.default.func,
  onBlur: _propTypes.default.func,
  onBrowse: _propTypes.default.func.isRequired,
  onSetupButtonClicked: _propTypes.default.func.isRequired,
  onUploadComplete: _propTypes.default.func,
  secrets: _propTypes.default.shape({
    token: _propTypes.default.string,
    secretKey: _propTypes.default.string,
    enableSignedUrls: _propTypes.default.bool
  }),
  buttons: _propTypes.default.node,
  children: _propTypes.default.node
};

function createEventHandler() {
  var events$ = new _rxjs.Subject();

  var handler = event => events$.next(event);

  return [events$.asObservable(), handler];
}

class MuxVideoInputUploader extends _react.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      isDraggingOver: false,
      invalidPaste: false,
      invalidFile: false,
      uploadProgress: null,
      fileInfo: null,
      uuid: null
    });

    _defineProperty(this, "dragEnteredEls", []);

    _defineProperty(this, "upload", null);

    _defineProperty(this, "ctrlDown", false);

    _defineProperty(this, "cancelUploadButton", /*#__PURE__*/_react.default.createRef());

    _defineProperty(this, "hiddenTextField", /*#__PURE__*/_react.default.createRef());

    _defineProperty(this, "container", /*#__PURE__*/_react.default.createRef());

    _defineProperty(this, "handleProgress", evt => {
      if (evt.percent) {
        this.setState({
          uploadProgress: evt.percent
        });
      }

      if (evt.file) {
        this.setState({
          fileInfo: evt.file
        });
      }
    });

    _defineProperty(this, "handleUploadFile", file => {
      this.setState({
        uploadProgress: 0,
        fileInfo: null,
        uuid: null
      });
      this.upload = (0, _upload.uploadFile)(file, {
        enableSignedUrls: this.props.secrets.enableSignedUrls
      }).pipe((0, _operators.takeUntil)(this.onCancelUploadButtonClick$.pipe((0, _operators.tap)(() => {
        if (this.state.uuid) {
          _SanityClient.default.delete(this.state.uuid);
        }
      })))).subscribe({
        complete: () => {
          this.setState({
            error: null,
            uploadProgress: null,
            uuid: null
          });
        },
        next: event => {
          this.handleUploadEvent(event);
        },
        error: err => {
          this.setState({
            error: err,
            uploadProgress: null,
            uuid: null
          });
        }
      });
    });

    _defineProperty(this, "handleUploadEvent", event => {
      switch (event.type) {
        case 'success':
          return this.handleUploadSuccess(event.asset);

        case 'progress':
          return this.handleProgress(event);

        case 'file':
          return this.setState({
            fileInfo: event.file
          });

        case 'uuid':
          // Means we created a mux.videoAsset document with an uuid
          return this.setState({
            uuid: event.uuid
          });

        case 'url':
          return this.setState({
            url: event.url,
            uploadProgress: 100
          });

        default:
          return null;
      }
    });

    _defineProperty(this, "handleUploadSuccess", assetDocument => {
      this.setState({
        uploadProgress: 100
      });

      if (this.props.onUploadComplete) {
        this.props.onUploadComplete(assetDocument);
      }
    });

    _defineProperty(this, "handlePaste", event => {
      var clipboardData = event.clipboardData || window.clipboardData;
      var url = clipboardData.getData('text');
      var options = {
        enableSignedUrls: this.props.secrets.enableSignedUrls
      };
      this.upload = (0, _upload.uploadUrl)(url, options).subscribe({
        complete: () => {
          this.setState({
            error: null,
            uploadProgress: null,
            url: null
          });
        },
        next: sEvent => {
          this.handleUploadEvent(sEvent);
        },
        error: err => {
          var error; // Don't output error dialog when just invalid url

          if (!err.message.toLowerCase().match('invalid url')) {
            error = err;
          }

          this.setState({
            invalidPaste: true,
            error
          }, () => {
            setTimeout(() => {
              this.setState({
                invalidPaste: false,
                uploadProgress: null
              });
            }, 2000);
          });
        }
      });
    });

    _defineProperty(this, "handleDrop", event => {
      this.setState({
        isDraggingOver: false
      });
      event.preventDefault();
      event.stopPropagation();
      (0, _extractFiles.extractDroppedFiles)(event.nativeEvent.dataTransfer).then(files => {
        if (files) {
          this.handleUploadFile(files[0]);
        }
      });
    });

    _defineProperty(this, "handleDragOver", event => {
      event.preventDefault();
      event.stopPropagation();
    });

    _defineProperty(this, "handleDragEnter", event => {
      event.stopPropagation();
      this.dragEnteredEls.push(event.target);
      this.setState({
        isDraggingOver: true
      });
    });

    _defineProperty(this, "handleDragLeave", event => {
      event.stopPropagation();
      var idx = this.dragEnteredEls.indexOf(event.target);

      if (idx > -1) {
        this.dragEnteredEls.splice(idx, 1);
      }

      if (this.dragEnteredEls.length === 0) {
        this.setState({
          isDraggingOver: false
        });
      }
    });

    _defineProperty(this, "handleCancelUploadButtonClicked", event => {
      this.setState({
        uploadProgress: null,
        error: null
      });
      this.container.current.focus();
    });

    _defineProperty(this, "handleErrorClose", event => {
      if (event) {
        event.preventDefault();
      }

      if (this.state.uploadProgress !== null) {
        return;
      }

      this.setState({
        invalidFile: false,
        invalidPaste: false,
        error: null,
        uploadProgress: null
      });
      this.container.current.focus();
    });

    _defineProperty(this, "handleSetupButtonClicked", event => {
      this.handleErrorClose(event);
      this.props.onSetupButtonClicked();
    });

    _defineProperty(this, "handleKeyDown", event => {
      if (event.keyCode == ctrlKey || event.keyCode == cmdKey) {
        this.ctrlDown = true;
      }

      var vKey = 86;

      if (this.ctrlDown && event.keyCode == vKey) {
        this.hiddenTextField.current.focus();
      }
    });

    _defineProperty(this, "handleKeyUp", event => {
      if (event.keyCode == ctrlKey || event.keyCode == cmdKey) {
        this.ctrlDown = false;
      }
    });

    _defineProperty(this, "handleFocus", event => {
      this.props.onFocus(event);
    });
  }

  componentWillUnmount() {
    this.unSubscribeToUpload();
  }

  componentDidMount() {
    var _createEventHandler = createEventHandler(),
        _createEventHandler2 = _slicedToArray(_createEventHandler, 2),
        onClick$ = _createEventHandler2[0],
        onClick = _createEventHandler2[1];

    this.onCancelUploadButtonClick$ = onClick$;
    this.handleCancelUploadButtonClick = onClick;
  }

  unSubscribeToUpload() {
    if (this.upload && !this.upload.closed) {
      this.upload.unsubscribe();
    }
  }

  renderUploadPlaceHolder() {
    if (this.props.children) {
      return null;
    }

    if (this.state.uploadProgress !== null) {
      return null;
    }

    var _this$state = this.state,
        invalidFile = _this$state.invalidFile,
        invalidPaste = _this$state.invalidPaste,
        isDraggingOver = _this$state.isDraggingOver;
    return /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement(_default3.default, {
      level: 0
    }, /*#__PURE__*/_react.default.createElement(_UploadPlaceholder.default, {
      isDraggingOver: isDraggingOver,
      hasFocus: this.props.hasFocus,
      invalidPaste: invalidPaste,
      invalidFile: invalidFile
    })), /*#__PURE__*/_react.default.createElement(_buttonCollection.default, null, /*#__PURE__*/_react.default.createElement(_FileInputButton.default, {
      icon: /*#__PURE__*/_react.default.createElement(_fi.FiUpload, {
        "data-sanity-icon": "upload"
      }),
      onSelect: files => this.handleUploadFile(files[0]),
      accept: 'video/*',
      text: "Upload"
    }), /*#__PURE__*/_react.default.createElement(_ui.Button, {
      mode: "ghost",
      tone: "default",
      text: "Browse",
      onClick: this.props.onBrowse
    })));
  } // eslint-disable-next-line complexity


  renderUploadProgress() {
    var _this$state2 = this.state,
        uploadProgress = _this$state2.uploadProgress,
        fileInfo = _this$state2.fileInfo,
        url = _this$state2.url;

    if (uploadProgress === null) {
      return null;
    }

    var text = uploadProgress < 100 ? "Uploading ".concat(fileInfo ? "'".concat(fileInfo.name, "'") : 'file') : 'Waiting for Mux to complete the file';

    if (this.state.error) {
      text = this.state.error.message;
    }

    if (url) {
      text = "Uploading ".concat(url);
    }

    return /*#__PURE__*/_react.default.createElement("div", {
      className: _Uploader.default.uploadProgress
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: _Uploader.default.progressBar
    }, /*#__PURE__*/_react.default.createElement(_bar.default, {
      percent: uploadProgress,
      text: text,
      isInProgress: uploadProgress === 100 && !this.state.error,
      showPercent: true,
      animation: true,
      color: "primary"
    })), (uploadProgress < 100 || this.state.error) && /*#__PURE__*/_react.default.createElement("div", {
      ref: this.cancelUploadButton
    }, /*#__PURE__*/_react.default.createElement(_ui.Button, {
      text: "Cancel upload",
      padding: 3,
      tone: "critical",
      onClick: this.handleCancelUploadButtonClick
    })));
  }

  renderError() {
    var _this$state3 = this.state,
        uploadProgress = _this$state3.uploadProgress,
        error = _this$state3.error;

    if (!error) {
      return null;
    }

    if (uploadProgress !== null) {
      return null;
    }

    var message = this.state.error.message;

    if (message === 'Invalid credentials') {
      message = /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("h3", null, "Invalid credentials"), /*#__PURE__*/_react.default.createElement("p", null, "You need to check your Mux access token and secret key."), /*#__PURE__*/_react.default.createElement(_ui.Button, {
        text: "Run setup",
        tone: "primary",
        padding: 3,
        onClick: this.handleSetupButtonClicked
      }));
    }

    return /*#__PURE__*/_react.default.createElement(_default2.default, {
      title: "Upload failed",
      color: "danger",
      useOverlay: true,
      onClose: this.handleErrorClose,
      onEscape: this.handleErrorClose,
      onClickOutside: this.handleErrorClose
    }, /*#__PURE__*/_react.default.createElement(_content.default, {
      size: "small"
    }, message));
  }

  renderButtons() {
    if (this.state.uploadProgress === null && this.props.buttons) {
      return /*#__PURE__*/_react.default.createElement(_ui.Grid, {
        columns: 4,
        gap: 2
      }, /*#__PURE__*/_react.default.createElement(_FileInputButton.default, {
        icon: /*#__PURE__*/_react.default.createElement(_icons.UploadIcon, {
          "data-sanity-icon": "upload"
        }),
        onSelect: files => this.handleUploadFile(files[0]),
        text: "Upload"
      }), this.props.buttons);
    }

    return null;
  }

  renderChildren() {
    if (this.state.uploadProgress !== null) {
      return null;
    }

    return this.props.children;
  }

  render() {
    return /*#__PURE__*/_react.default.createElement(_ui.Card, {
      padding: 0,
      radius: 0,
      shadow: 0,
      tabIndex: 0,
      onBlur: this.props.onBlur,
      onFocus: this.props.onFocus,
      onDrop: this.handleDrop,
      onKeyDown: this.handleKeyDown,
      onDragOver: this.handleDragOver,
      onDragLeave: this.handleDragLeave,
      onDragEnter: this.handleDragEnter,
      ref: this.container
    }, /*#__PURE__*/_react.default.createElement("input", {
      ref: this.hiddenTextField,
      className: _Uploader.default.hiddenTextField,
      type: "text",
      onPaste: this.handlePaste
    }), this.renderError(), this.renderUploadProgress(), this.renderUploadPlaceHolder(), this.renderChildren(), this.renderButtons());
  }

}

MuxVideoInputUploader.propTypes = propTypes;
MuxVideoInputUploader.defaultProps = {
  hasFocus: false,
  onFocus: null,
  onBlur: null,
  onUploadComplete: null,
  secrets: {
    token: '',
    secretKey: '',
    enableSignedUrls: false
  },
  buttons: null,
  children: null
};
var _default = MuxVideoInputUploader;
exports.default = _default;
//# sourceMappingURL=Uploader.js.map